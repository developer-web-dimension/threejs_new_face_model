<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MediaPipe Blendshapes Face Tracking</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #2a2a2a 100%);
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      position: relative;
    }
    
    /* Animated background grid */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(rgba(196, 65, 217, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(196, 65, 217, 0.03) 1px, transparent 1px);
      background-size: 50px 50px;
      animation: gridMove 20s linear infinite;
      pointer-events: none;
      z-index: 0;
    }
    
    @keyframes gridMove {
      0% { transform: translate(0, 0); }
      100% { transform: translate(50px, 50px); }
    }
    
    /* Splashscreen Styles */
    .splashscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.8s ease-out, transform 0.8s ease-out;
    }
    
    .splashscreen.fade-out {
      opacity: 0;
      transform: scale(1.1);
    }
    
    .splash-logo {
      width: 120px;
      height: 120px;
      /* background: linear-gradient(45deg, #00d4ff, #ff6b6b, #4ecdc4); */
      border-radius: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 30px;
      box-shadow: 0 20px 40px rgba(0, 212, 255, 0.3);
      animation: pulse 2s infinite ease-in-out;
      padding: 15px;
    }
    
    .splash-logo img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: brightness(1.1) contrast(1.1);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    @keyframes blink {
      0%, 90%, 100% { opacity: 1; }
      95% { opacity: 0.3; }
    }
    
    .splash-title {
      color: white;
      font-size: 32px;
      font-weight: 300;
      margin-bottom: 15px;
      text-align: center;
      opacity: 0;
      animation: fadeInUp 1s 0.5s forwards;
    }
    
    .splash-subtitle {
      color: #888;
      font-size: 16px;
      text-align: center;
      opacity: 0;
      animation: fadeInUp 1s 0.8s forwards;
    }
    
    .splash-progress {
      margin-top: 40px;
      width: 200px;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
    }
    
    .splash-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #00d4ff, #ff6b6b);
      border-radius: 2px;
      width: 0%;
      animation: progressLoad 4.5s ease-out forwards;
    }
    
    @keyframes progressLoad {
      0% { width: 0%; }
      100% { width: 100%; }
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Enhanced corner branding with premium styling */
    .corner-branding {
      position: fixed;
      bottom: 24px;
      right: 24px;
      z-index: 100;
      opacity: 0;
      transform: translateY(30px) scale(0.9);
      transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      gap: 16px;
      background: rgb(255, 255, 255);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(196, 65, 217, 0.2);
      border-radius: 24px;
      padding: 16px 20px;
      box-shadow: 
        0 12px 40px rgba(0, 0, 0, 0.4),
        0 4px 12px rgba(196, 65, 217, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      cursor: pointer;
      user-select: none;
    }
    .corner-branding:active {
      opacity: 0;
    }
    .corner-branding.show {
      transform: translateY(0) scale(1) !important;
      opacity: 1 !important;
      visibility: visible !important;
      display: flex !important;
      pointer-events: auto;
    }
    
    .corner-branding:hover {
      transform: translateY(-6px) scale(1.02);
      background: rgb(249, 249, 249);
      border-color: rgb(255, 255, 255);
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.5),
        0 8px 20px rgba(196, 65, 217, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }
    
    .corner-branding::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border-radius: 24px;
      background: white;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    
    .corner-branding:hover::before {
      opacity: 1;
    }
    
    .corner-logo {
      width: 65px;
      height: 65px;
      /* background: linear-gradient(135deg, #c441d9 0%, #9c27b0 50%, #673ab7 100%); */
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      padding: 1px;
      position: relative;
      overflow: hidden;
      pointer-events: none !important;
      /* box-shadow: 
        0 4px 12px rgb(255, 255, 255),
        inset 0 1px 0 rgba(255, 255, 255, 0.2); */
    }
    
    .corner-logo::before {
      content: '';
      position: absolute;
      top: -20%;
      left: -20%;
      width: 200%;
      height: 200%;
      background: linear-gradient(45deg, 
        transparent 30%, 
        rgba(255, 255, 255, 0.3) 50%, 
        transparent 70%);
      transform: translateX(-100%) translateY(-100%) rotate(45deg);
      transition: transform 0.6s ease;
    }
    
    .corner-branding:hover .corner-logo::before {
      transform: translateX(100%) translateY(100%) rotate(45deg);
    }
    
    .corner-logo img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      /* filter: brightness(1.3) contrast(1.2) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3)); */
      position: relative;
      z-index: 1;
      transition: transform 0.3s ease;
    }
    
    .corner-branding:hover .corner-logo img {
      transform: scale(1.1) rotate(5deg);
    }
    
    .corner-text {
      color: black;
      font-size: 13px;
      font-weight: 500;
      line-height: 1.3;
      /* text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5); */
      white-space: nowrap;
      pointer-events: none !important;
    }
    
    .corner-text .brand {
      display: block;
      font-size: 10px;
      color: rgb(0, 0, 0);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 3px;
      font-weight: 600;
      pointer-events: none !important;
    }
    
    .corner-text .company {
      display: block;
      font-weight: 700;
      font-size: 16px;
      background: linear-gradient(135deg, #c441d9 0%, #9c27b0 50%, #673ab7 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: none;
      pointer-events: none !important;
    }
    
    .container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    canvas {
      position: absolute;
      transform: scaleX(-1);
      z-index: 1;
      box-shadow: 0 0 30px rgba(121, 53, 53, 0.3);
      max-width: 100vw;
      max-height: 100vh;
    }
   
    video {
      display: none;
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 18px;
      z-index: 10;
      text-align: center;
    }

    .debug-info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 12px;
      z-index: 20;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      max-width: 300px;
    }

    /* Responsive styles */
    @media screen and (max-width: 768px) {
      canvas {
        object-fit: cover !important;
        width: 100vw !important;
        height: 100vh !important;
      }
      
      .container {
        overflow: hidden;
      }
      
      .splash-title {
        font-size: 24px;
      }
      
      .corner-branding {
        bottom: 20px;
        right: 20px;
        padding: 12px 16px;
        gap: 12px;
        border-radius: 20px;
      }
      
      .corner-logo {
        width: 44px;
        height: 44px;
        padding: 1px;
        border-radius: 12px;
      }
      
      .corner-text {
        font-size: 11px;
      }
      
      .corner-text .brand {
        font-size: 9px;
        letter-spacing: 0.5px;
      }
      
      .corner-text .company {
        font-size: 16px;
      }
    }

    @media screen and (max-height: 600px) and (orientation: landscape) {
      canvas {
        height: 100vh !important;
        width: auto !important;
        object-fit: cover !important;
      }
    }

    @media screen and (orientation: portrait) {
      canvas {
        object-fit: cover !important;
      }
    }
  </style>
</head>
<body>
  <!-- Splashscreen -->
  <div class="splashscreen" id="splashscreen">
    <div class="splash-logo">
      <img src="./models/logo.png" alt="Logo" />
    </div>
    <h1 class="splash-title">Face Tracker</h1>
    <p class="splash-subtitle">Powered by Web Dimension</p>
    <div class="splash-progress">
      <div class="splash-progress-bar"></div>
    </div>
  </div>
  
  <!-- Corner Branding -->
   <a href="https://www.instagram.com/web_dimesion?igsh=MWtyczFvNDZlMTg5NA==" target="_blank" >
  <div class="corner-branding" id="cornerBranding" title="Web Dimension" >
    <div class="corner-logo">
      <img src="./models/logo.png" alt="Web Dimension Logo" />
    </div>
    <div class="corner-text">
      <span class="brand" style="color:black">Powered by</span>
      <span class="company" style="color:black">Web Dimension</span>
    </div>
  </div>
  </a>

  <!-- Floating Particles -->
  <div class="particles" id="particles"></div>
  
  <!-- Main Content -->
  <div class="container">
    <video autoplay playsinline muted id="video"></video>
    <div class="loading" id="loading">Loading camera and AI model...</div>
    <!-- <div class="debug-info" id="debug" style="display: none;"></div> -->
  </div>

  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/": "https://unpkg.com/three@0.150.1/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";
    import { KTX2Loader } from "three/examples/jsm/loaders/KTX2Loader";
    import { DRACOLoader } from "three/examples/jsm/loaders/DRACOLoader";
    import {
      FilesetResolver,
      FaceLandmarker
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.1.0-alpha-16";

    // Enhanced splashscreen management
    function hideSplashscreen() {
      const splashscreen = document.getElementById('splashscreen');
      const cornerBranding = document.getElementById('cornerBranding');
      
      splashscreen.classList.add('fade-out');
      
      setTimeout(() => {
        splashscreen.style.display = 'none';
        // Show corner branding after splashscreen disappears
        setTimeout(() => {
          cornerBranding.classList.add('show');
          createParticles();
        }, 200);
      }, 800);
    }
    cornerBranding.classList.remove('hide');
   document.getElementById('cornerBranding').addEventListener('click', () => {
    console.log('Clicked cornerBranding:', cornerBranding.classList);
  });

    // Enhanced particle system with better performance
    function createParticles() {
      const particlesContainer = document.getElementById('particles');
      const particleCount = 12;
      
      for (let i = 0; i < particleCount; i++) {
        setTimeout(() => {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.animationDelay = Math.random() * 8 + 's';
          particle.style.animationDuration = (6 + Math.random() * 6) + 's';
          
          // Add random horizontal drift
          const drift = (Math.random() - 0.5) * 100;
          particle.style.setProperty('--drift', drift + 'px');
          
          particlesContainer.appendChild(particle);
          
          // Remove particle after animation completes
          setTimeout(() => {
            if (particle.parentNode) {
              particle.parentNode.removeChild(particle);
            }
          }, 12000);
        }, i * 600);
      }
      
      // Continuously create new particles
      setTimeout(createParticles, 8000);
    }

    // Hide splashscreen after 5 seconds
    setTimeout(hideSplashscreen, 5000);

    function getViewportSizeAtDepth(camera, depth) {
      const viewportHeightAtDepth =
        2 * depth * Math.tan(THREE.MathUtils.degToRad(0.5 * camera.fov));
      const viewportWidthAtDepth = viewportHeightAtDepth * camera.aspect;
      return new THREE.Vector2(viewportWidthAtDepth, viewportHeightAtDepth);
    }

    function createCameraPlaneMesh(camera, depth, material) {
      if (camera.near > depth || depth > camera.far) {
        console.warn("Camera plane geometry will be clipped by the `camera`!");
      }
      const viewportSize = getViewportSizeAtDepth(camera, depth);
      const cameraPlaneGeometry = new THREE.PlaneGeometry(
        viewportSize.width,
        viewportSize.height
      );
      cameraPlaneGeometry.translate(0, 0, -depth);

      return new THREE.Mesh(cameraPlaneGeometry, material);
    }

    class BasicScene {
      constructor() {
        this.lastTime = 0;
        this.callbacks = [];
        this.videoElement = null;
        this.inputFramesPlane = null;
        
        // Initialize dimensions
        this.updateDimensions();
        
        // Set up the Three.js scene, camera, and renderer
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(
          60,
          this.width / this.height,
          0.01,
          5000
        );

        this.renderer = new THREE.WebGLRenderer({ 
          antialias: true,
          alpha: true,
          powerPreference: "high-performance"
        });
        
        this.setupRenderer();
        this.setupLighting();
        this.setupCamera();
        
        // Add resize listeners
        this.setupEventListeners();
        
        // Start render loop
        this.render();
      }

      updateDimensions() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
      }

      setupRenderer() {
        this.renderer.setSize(this.width, this.height);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
        this.renderer.setClearColor(0x000000, 1); // Ensure black background
        
        const canvas = this.renderer.domElement;
        canvas.style.display = 'block';
        canvas.style.position = 'absolute';
        canvas.style.top = '50%';
        canvas.style.left = '50%';
        canvas.style.transform = 'translate(-50%, -50%) scaleX(-1)';
        canvas.style.objectFit = 'cover';
        canvas.style.maxWidth = '100vw';
        canvas.style.maxHeight = '100vh';
        
        document.querySelector('.container').appendChild(canvas);
      }

      setupLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(0, 1, 1);
        this.scene.add(directionalLight);
      }

      setupCamera() {
        this.camera.position.z = 0;
      }

      setupVideoBackground(videoElement) {
        this.videoElement = videoElement;
        
        // Remove existing video plane if it exists
        if (this.inputFramesPlane) {
          this.scene.remove(this.inputFramesPlane);
        }
        
        // Wait for video to have actual dimensions
        if (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {
          console.log("Video not ready yet, retrying...");
          setTimeout(() => this.setupVideoBackground(videoElement), 100);
          return;
        }
        
        console.log(`Video dimensions: ${videoElement.videoWidth}x${videoElement.videoHeight}`);
        
        const inputFrameTexture = new THREE.VideoTexture(videoElement);
        inputFrameTexture.colorSpace = THREE.SRGBColorSpace;
        inputFrameTexture.generateMipmaps = false;
        inputFrameTexture.minFilter = THREE.LinearFilter;
        inputFrameTexture.magFilter = THREE.LinearFilter;
        inputFrameTexture.wrapS = THREE.ClampToEdgeWrapping;
        inputFrameTexture.wrapT = THREE.ClampToEdgeWrapping;
        
        // Calculate proper aspect ratios to prevent stretching
        const videoAspect = videoElement.videoWidth / videoElement.videoHeight;
        const viewportAspect = this.width / this.height;
        
        // Use a larger depth to ensure video background is behind everything
        const inputFramesDepth = 1000;
        const viewportSize = getViewportSizeAtDepth(this.camera, inputFramesDepth);
        
        let planeWidth, planeHeight;
        
        // Calculate plane dimensions to maintain video aspect ratio while filling viewport
        if (videoAspect > viewportAspect) {
          // Video is wider than viewport - fit to height, crop width
          planeHeight = viewportSize.height;
          planeWidth = planeHeight * videoAspect;
        } else {
          // Video is taller than viewport - fit to width, crop height
          planeWidth = viewportSize.width;
          planeHeight = planeWidth / videoAspect;
        }
        
        // Create plane geometry with calculated dimensions
        const cameraPlaneGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        cameraPlaneGeometry.translate(0, 0, -inputFramesDepth);
        
        this.inputFramesPlane = new THREE.Mesh(
          cameraPlaneGeometry,
          new THREE.MeshBasicMaterial({ 
            map: inputFrameTexture,
            side: THREE.DoubleSide
          })
        );
        
        this.scene.add(this.inputFramesPlane);
        console.log("Video background plane created and added to scene");
        console.log(`Plane dimensions: ${planeWidth.toFixed(2)}x${planeHeight.toFixed(2)}`);
        console.log(`Video aspect: ${videoAspect.toFixed(2)}, Viewport aspect: ${viewportAspect.toFixed(2)}`);
        
        // Update debug info
        this.updateDebugInfo();
      }

      updateDebugInfo() {
        const debug = document.getElementById('debug');
        if (debug && this.videoElement) {
          const videoAspect = this.videoElement.videoWidth / this.videoElement.videoHeight;
          const viewportAspect = this.width / this.height;
          
          debug.innerHTML = `
            Video: ${this.videoElement.videoWidth}x${this.videoElement.videoHeight}<br>
            Canvas: ${this.width}x${this.height}<br>
            Video Aspect: ${videoAspect.toFixed(2)}<br>
            Viewport Aspect: ${viewportAspect.toFixed(2)}<br>
            Playing: ${!this.videoElement.paused}<br>
            Time: ${this.videoElement.currentTime.toFixed(1)}s
          `;
          debug.style.display = 'block';
        }
      }

      setupEventListeners() {
        let resizeTimeout;
        
        const handleResize = () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            this.resize();
          }, 100);
        };

        window.addEventListener("resize", handleResize);
        window.addEventListener("orientationchange", () => {
          setTimeout(handleResize, 300);
        });
        
        // Handle visibility changes to optimize performance
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            this.paused = true;
          } else {
            this.paused = false;
            this.render();
          }
        });

        // Add click to toggle debug info
        window.addEventListener('click', () => {
          const debug = document.getElementById('debug');
          if (debug) {
            debug.style.display = debug.style.display === 'none' ? 'block' : 'none';
          }
        });
      }

      resize() {
        this.updateDimensions();
        
        this.camera.aspect = this.width / this.height;
        this.camera.updateProjectionMatrix();

        this.renderer.setSize(this.width, this.height);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Update video background if it exists
        if (this.videoElement && this.inputFramesPlane) {
          this.setupVideoBackground(this.videoElement);
        }

        this.renderer.render(this.scene, this.camera);
      }

      render(time = this.lastTime) {
        if (this.paused) return;
        
        const delta = (time - this.lastTime) / 1000;
        this.lastTime = time;
        
        // Call all registered callbacks with deltaTime parameter
        for (const callback of this.callbacks) {
          callback(delta);
        }
        
        // Render the scene
        this.renderer.render(this.scene, this.camera);
        
        // Request next frame
        requestAnimationFrame((t) => this.render(t));
      }
    }

    class Avatar {
      constructor(url, scene) {
        this.loader = new GLTFLoader();
        this.morphTargetMeshes = [];
        this.url = url;
        this.scene = scene;
        this.setupLoaders().then(() => {
          this.loadModel(this.url);
        });
      }

      async setupLoaders() {
        // Setup KTX2 loader for compressed textures
        const ktx2Loader = new KTX2Loader();
        ktx2Loader.setTranscoderPath('https://unpkg.com/three@0.150.1/examples/jsm/libs/basis/');
        this.loader.setKTX2Loader(ktx2Loader);

        // Setup Draco loader for compressed geometry
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://unpkg.com/three@0.150.1/examples/jsm/libs/draco/');
        this.loader.setDRACOLoader(dracoLoader);

        // Setup Meshopt decoder for additional compression
        try {
          const { MeshoptDecoder } = await import('https://unpkg.com/three@0.150.1/examples/jsm/libs/meshopt_decoder.module.js');
          this.loader.setMeshoptDecoder(MeshoptDecoder);
          console.log("MeshoptDecoder loaded successfully");
        } catch (error) {
          console.warn("MeshoptDecoder failed to load:", error);
        }
      }

      loadModel(url) {
        this.url = url;
        console.log("Attempting to load model from:", url);
        
        this.loader.load(
          url,
          (gltf) => {
            if (this.gltf) {
              this.scene.remove(this.gltf.scene);
              this.morphTargetMeshes = [];
            }
            this.gltf = gltf;
            
            console.log("Model loaded successfully:", gltf);
            
            this.scene.add(gltf.scene);
            
            // Scale and position the model
            gltf.scene.scale.setScalar(1.0);
            gltf.scene.position.set(0, 0, -100); // Move model closer to camera
            
            this.init(gltf);
            console.log("Avatar model loaded and added to scene successfully");
          },
          (progress) => {
            const percent = Math.round(100.0 * (progress.loaded / progress.total));
          },
          (error) => {
            console.error("Error loading avatar model:", error);
            console.error("Failed URL:", url);
            
            // Try to create a simple fallback geometry
            this.createFallbackModel();
          }
        );
      }

      createFallbackModel() {
        console.log("Creating fallback model...");
        
        // Create a simple sphere as fallback
        const geometry = new THREE.SphereGeometry(50, 32, 32);
        const material = new THREE.MeshLambertMaterial({ color: 0x888888 });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.set(0, 0, -200);
        
        this.scene.add(sphere);
        
        // Hide loading message
        const loading = document.getElementById("loading");
        if (loading) {
          loading.textContent = "Using fallback model (sphere)";
          loading.style.color = "yellow";
          setTimeout(() => {
            loading.style.display = "none";
          }, 2000);
        }
        
        console.log("Fallback model created");
      }

      init(gltf) {
        console.log("Initializing model...");
        
        gltf.scene.traverse((object) => {
          if (object.isBone && !this.root) {
            this.root = object;
            console.log("Found root bone:", object);
          }
          
          if (!object.isMesh) return;

          const mesh = object;
          mesh.frustumCulled = false;
          
          console.log("Processing mesh:", mesh.name);
          console.log("Mesh has morphTargetDictionary:", !!mesh.morphTargetDictionary);
          console.log("Mesh has morphTargetInfluences:", !!mesh.morphTargetInfluences);
          
          if (mesh.morphTargetDictionary) {
            console.log("Morph targets:", Object.keys(mesh.morphTargetDictionary));
            
            if (mesh.material) {
              mesh.material.morphTargets = true;
              // mesh.material.colorWrite = false; // Commented out so you can see the face model
              mesh.material.needsUpdate = true;
            }
            
            if (!mesh.morphTargetInfluences) {
              mesh.morphTargetInfluences = new Array(Object.keys(mesh.morphTargetDictionary).length).fill(0);
            }
            
            this.morphTargetMeshes.push(mesh);
          }
        });
        
        console.log("Model initialization complete");
        console.log("Total morph target meshes:", this.morphTargetMeshes.length);
        
        // Hide loading message once model is ready
        const loading = document.getElementById("loading");
        if (loading) {
          loading.style.display = "none";
        }
      }

      updateBlendshapes(blendshapes) {
        for (const mesh of this.morphTargetMeshes) {
          if (!mesh.morphTargetDictionary || !mesh.morphTargetInfluences) {
            continue;
          }
          
          for (const [name, value] of blendshapes) {
            if (!mesh.morphTargetDictionary.hasOwnProperty(name)) {
              continue;
            }

            const idx = mesh.morphTargetDictionary[name];
            let finalValue = Math.max(0, Math.min(1, value));
            
            if (name.includes('eyeBlink') || name.includes('browOuter')) {
              finalValue = Math.min(1, finalValue * 1.2);
            }
            
            mesh.morphTargetInfluences[idx] = finalValue;
          }
          
          mesh.morphTargetInfluences.needsUpdate = true;
        }
      }

      applyMatrix(matrix, matrixRetargetOptions) {
        const { scale = 1 } = matrixRetargetOptions || {};
        
        // Apply to main face model
        if (this.gltf) {
          const faceMatrix = matrix.clone();
          faceMatrix.scale(new THREE.Vector3(scale, scale, scale));
          this.gltf.scene.matrixAutoUpdate = false;
          this.gltf.scene.matrix.copy(faceMatrix);
        }
      }

      setVisible(visible) {
      if (this.gltf && this.gltf.scene) {
        this.gltf.scene.visible = visible;
      }
    }

    }
    
    let faceLandmarker;
    let video;
    let isModelReady = false;

    const scene = new BasicScene();
    
    const modelUrl = "./models/face.glb"; 
    const avatar = new Avatar(modelUrl, scene.scene);
    


    function detectFaceLandmarks(time) {
      if (!faceLandmarker || !isModelReady) return;
      
      try {
        const landmarks = faceLandmarker.detectForVideo(video, time);

        // Check if any face is detected
        const hasFace = landmarks.facialTransformationMatrixes && 
                      landmarks.facialTransformationMatrixes.length > 0;
        
        if (hasFace) {
          // Show the avatar model
          avatar.setVisible(true);
          
          const transformationMatrices = landmarks.facialTransformationMatrixes;
          const matrix = new THREE.Matrix4().fromArray(transformationMatrices[0].data);
          avatar.applyMatrix(matrix, { scale: 10 });

          // Apply blendshapes
          const blendshapes = landmarks.faceBlendshapes;
          if (blendshapes && blendshapes.length > 0) {
            const coefsMap = retarget(blendshapes);
            avatar.updateBlendshapes(coefsMap);
          }
        } else {
          // Hide the avatar model when no face is detected
          avatar.setVisible(false);
        }
      } catch (error) {
        console.warn("Face detection error:", error);
        // Hide avatar on error as well
        avatar.setVisible(false);
      }
    }

    function retarget(blendshapes) {
      const categories = blendshapes[0].categories;
      const coefsMap = new Map();
      
      for (const blendshape of categories) {
        const categoryName = blendshape.categoryName;
        let score = blendshape.score;
        let mappedName = null;
        
        switch (categoryName) {
          case "eyeBlinkLeft":
            mappedName = "eyeBlink_L";
            score *= 1.2;
            break;
          case "eyeBlinkRight":
            mappedName = "eyeBlink_R";
            score *= 1.2;
            break;
          case "eyeSquintLeft":
            mappedName = "eyeSquint_L";
            break;
          case "eyeSquintRight":
            mappedName = "eyeSquint_R";
            break;
          case "eyeWideLeft":
            mappedName = "eyeWide_L";
            break;
          case "eyeWideRight":
            mappedName = "eyeWide_R";
            break;
          case "browInnerUp":
            mappedName = "browInnerUp";
            score *= 1.2;
            break;
          case "browDownLeft":
            mappedName = "browDown_L";
            break;
          case "browDownRight":
            mappedName = "browDown_R";
            break;
          case "browOuterUpLeft":
            mappedName = "browOuterUp_L";
            score *= 1.2;
            break;
          case "browOuterUpRight":
            mappedName = "browOuterUp_R";
            score *= 1.2;
            break;
          case "mouthSmileLeft":
            mappedName = "mouthSmile_L";
            break;
          case "mouthSmileRight":
            mappedName = "mouthSmile_R";
            break;
          case "mouthFrownLeft":
            mappedName = "mouthFrown_L";
            break;
          case "mouthFrownRight":
            mappedName = "mouthFrown_R";
            break;
          case "jawOpen":
            mappedName = "jawOpen";
            break;
          default:
            mappedName = categoryName;
            break;
        }
        
        if (mappedName) {
          coefsMap.set(mappedName, score);
        }
      }
      
      return coefsMap;
    }

    function onVideoFrame(time) {
      detectFaceLandmarks(time);
      if (video && !video.paused) {
        video.requestVideoFrameCallback(onVideoFrame);
      }
    }

    async function streamWebcamThroughFaceLandmarker() {
      video = document.getElementById("video");
      
      function onAcquiredUserMedia(stream) {
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          console.log(`Video loaded: ${video.videoWidth}x${video.videoHeight}`);
          video.play().then(() => {
            console.log("Video started playing");
            scene.setupVideoBackground(video);
            
            // Start face detection after a short delay
            setTimeout(() => {
              video.requestVideoFrameCallback(onVideoFrame);
            }, 500);
          });
        };
      }

      try {
        console.log("Requesting camera access...");
        
        const constraints = {
          audio: false,
          video: {
            facingMode: "user",
            width: { ideal: 1280, max: 1920 },
            height: { ideal: 720, max: 1080 },
            frameRate: { ideal: 30 }
          }
        };
        
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        onAcquiredUserMedia(stream);
        
      } catch (error) {
        console.error("Camera access failed:", error);
        
        // Try with simpler constraints
        try {
          const fallbackStream = await navigator.mediaDevices.getUserMedia({
            audio: false,
            video: { facingMode: "user" }
          });
          onAcquiredUserMedia(fallbackStream);
        } catch (fallbackError) {
          console.error("Fallback camera access failed:", fallbackError);
          const loading = document.getElementById("loading");
          if (loading) {
            loading.textContent = "Camera access denied. Please allow camera access and refresh.";
            loading.style.color = "red";
          }
        }
      }
    }

    async function run() {
      try {
        console.log("Starting application...");
        
        // Initialize MediaPipe first
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.1.0-alpha-16/wasm"
        );
        
        faceLandmarker = await FaceLandmarker.createFromModelPath(
          vision,
          "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task"
        );
        
        await faceLandmarker.setOptions({
          baseOptions: { delegate: "GPU" },
          runningMode: "VIDEO",
          outputFaceBlendshapes: true,
          outputFacialTransformationMatrixes: true
        });

        isModelReady = true;
        console.log("MediaPipe Face Landmarker initialized successfully");
        
        // Start camera stream
        await streamWebcamThroughFaceLandmarker();
        
      } catch (error) {
        console.error("Initialization error:", error);
        const loading = document.getElementById("loading");
        if (loading) {
          loading.textContent = "Failed to initialize. Check console for details.";
          loading.style.color = "red";
        }
      }
    }

    run();
  </script>
</body>
</html>